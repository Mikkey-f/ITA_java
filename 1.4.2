先找到马的位置，卒不能在的位置（日字形）
    n[i][j]=1
    n[i-1][j+2]=1
    n[i-1][j-2]=1
    n[i+1][j+2]=1
    n[i+1][j-2]=1
    n[i+2][j+1]=1
    n[i+2][j-1]=1
    n[i-2][j+1]=1
    n[i-2][j-1]=1
(赋初值表示这个位置不能走）
在表示卒行走的方式：向下走一，向右走一
路径数等于不为1的所有之和



学习一下简单算法
1.二分法（力扣704）
区间：左闭右闭；左闭右开
Eg：左闭右闭
left=0;right=num.size-1;while(left<=right){middle=(left+right)/2;if(nums[middle]>target)
right=middle-1;else if(nums[middle]<target)left=middle+1;else return middle;}
return -1;
左闭右开
left=0;right=numsize-1;while(left<right){middle=(left+right)/2;if(nums[middle]>target)
right=middle;else if(nums[middle]<target)left=middle+1;else return middle;}
return -1;
2.移除元素（力扣27）
双指针：
slow=0;for(fast=0;fast<nums.size;fast++){
If(fast(nums[fast]!=val){
nums[slow]=nums[fast];
slow++;}}
return slow;
Ps:fast指针是用来获取新数组中的元素；slow指针是获取我们新数组中需要更新的位置
3.有序数组的平方（力扣977）
-5	1	2	3
→                                                           ←
i                                                             j
双指针：
vector<int>result
k=num.size-1
for(i=0,j=num.size-1;i<=j;){
If(nums[i]*nums[i]>nums[j]*nums[j]){
result[k--]=nums[i]*nums[i];
i++;}
else{
result[k--]=nums[j]*nums[j];
j--;}
}
return result;
