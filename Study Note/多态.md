# 多态

## 一.介绍

Java 中的多态是面向对象编程的重要特性，指同一接口被不同类型对象使用时呈现不同行为。它主要有静态多态（编译时多态 ）和动态多态（运行时多态）两种形式，具体如下：

### 静态多态：

**定义：**在同一个类中，允许存在多个同名方法，只要它们的参数列表（参数个数、类型、顺序）不同。编译器根据调用方法时实际传入的参数类型和数量，在编译阶段就确定调用哪个方法 。

**示例：**

```java
class Calculator {
    int add(int a, int b) {
        return a + b;
    }
    double add(double a, double b) {
        return a + b;
    }
    int add(int a, int b, int c) {
        return a + b + c;
    }
}
```



### 动态多态：

- 实现条件
  - **继承**：存在子类继承父类的关系 。
  - **重写**：子类对父类中某些方法进行重写，即子类提供与父类方法名、参数列表、返回类型（协变返回类型情况除外）完全相同的方法实现 。
  - **向上转型**：用子类对象赋值给父类引用，如`Animal animal = new Dog();` （`Dog`是`Animal`子类 ） 。
- **运行机制**：当通过父类引用调用被重写的方法时，实际执行的是子类重写后的方法，这是在运行时根据对象实际类型确定的，即动态绑定 。





## 二.具体体现

![image-20250428201218440](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250428201218440.png)

![image-20250428201758486](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250428201758486.png)

```java
public class Animal {
    public void cry(){
        System.out.println("动物在叫唤.....");
    }
}

public class Cat extends Animal {
    @Override
    public void cry() {
        System.out.println("Cat cry() 小猫喵喵叫");
    }
}

public class Dog extends Animal {
    @Override
    public void cry() {
        System.out.println("Dog cry()  小狗汪汪叫");
    }
}

public class polyobject {
    public static void main(String[] args) {
        //体验对象多态的特点

        Animal animal=new Dog();
        //animal的编译类型是Animal，运行类型为Dog
        animal.cry();
        //运行时，animal的运行类型为Dog，所有cry是Dog的cry
        //输出小狗汪汪叫
        animal=new Cat();
        animal.cry();
        //输出小猫喵喵叫
    }
}
```



## 三.快速入门

```java

//主人给小狗喂食骨头
    public void feed(Dog dog,Bone bone){
        System.out.println("主人"+name+"给"+dog.getName()+"喂食"+bone.getName());
    }

    //主人给小猫喂食鱼
    public void feed(Cat cat,Fish fish){
        System.out.println("主人"+name+"给"+cat.getName()+"喂食"+fish.getName());
    }

    //使用多态可以统一管理主人喂食物的问题
    //animal的编译类型是Animal，可以指向（接收）Animal子类的对象
    //food的编译类型是Food，可以指向（接收）Food子类的对象
    public void feed(Animal animal,Food food){
        System.out.println("主人"+name+"给"+animal.getName()+"喂食"+food.getName());
    }
```



## 四.向上转型



![image-20250429143000201](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250429143000201.png)

## 五.向下转型

![image-20250429151113310](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250429151113310.png)

```java
//向上和向下转型示例

public class Animal {
    String name="动物";
    int age=10;
    public void eat(){
        System.out.println("吃");
    }
    public void sleep(){
        System.out.println("睡觉");
    }
    private void drink(){
        System.out.println("喝");
    }
}

public class Cat extends Animal{
    public void eat(){
        System.out.println("猫吃鱼");
    }
    public void CatchMouse(){//特有方法
        System.out.println("猫抓鱼");
    }
}
```

```java
public class test {
    public static void main(String[] args) {
        //向上转型：父类的引用指向了子类的对象
        Animal animal =new Cat();
        Object object=new Cat();//正确，Object也是Cat的父类
        //向上转型调用方法规则：
        //1.可以调用父类的所有成员（需要遵守访问权限），但不能调用子类的特有成员
        //在编译阶段，能调用的成员由编译类型来决定，Animal中没有CatchMouse方法
        //animal.CatchMouse();//错误
        //animal.drink();//报错：私有方法不能访问

        //运行时看子类(运行类型)的具体实现，即调用方法时从子类（运行类型）开始查找方法
        animal.eat();//输出 猫吃鱼
        animal.sleep();//输出 睡觉
        
        //希望可以调用Cat的CatchMouse方法
        //向下转型
        Cat cat = (Cat) animal;
        cat.CatchMouse();

        Dog dog =(Dog) animal;//错误，类异常
        //animal指向的对象是Cat类型，则不能将其强制转换为Dog类型，两者没有关系
    }
}
```



## 六.属性的细节

![image-20250429155652437](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250429155652437.png)



```java
1.
    public class Base {
    int count=10;
}

class Sub extends Base{
    int count =1;
}
class test{
    public static void main(String[] args) {
        //属性没有重写之说，属性的值看编译类型
        Base base =new Sub();
        System.out.println(base.count);//输出10
    }
}

2.
    public class test {
    public static void main(String[] args) {
        AA aa=new AA();
        System.out.println(aa instanceof AA);//true
        System.out.println(aa instanceof BB);//false
        AA a=new BB();
        System.out.println(a instanceof AA);//true
        System.out.println(a instanceof BB);//true
        Object obj=new Object();
        String s="sizhijun";
        System.out.println(s instanceof Object);//true
    }
}
class AA{}
class BB extends AA{}
```



## 七.多态的应用

### 1.多态数组

**定义：**数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

###### 示例：

先定义几个类

```java
package com.poly.polyarr;

//父类Person
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String say() {//返回信息
        return name + "\t" + age;
    }
}
```

```java
//子类Student
public class Student extends Person{
    private int score ;

    public Student(String name, int age, int score) {
        super(name, age);
        this.score = score;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    @Override
    public String say() {
        return "学生"+ super.say()+" score="+score;
    }
    public void study(){
        System.out.println("学生"+getName()+"正在学习");
    }
}

public class Teacher extends Person{
    private double salary;

    public Teacher(String name, int age, double salary) {
        super(name, age);
        this.salary = salary;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    @Override
    public String say() {
        return "老师"+ super.say()+" salary="+salary;
    }
    public void teach(){
        System.out.println("老师"+getName()+"正在教java...");
    }
}

```

接下来建立一个多态数组

```java
public class polyArray {
    public static void main(String[] args) {
        Person[] persons = new Person[5];
        persons[0] = new Person("jack", 18);
        persons[1] = new Student("sizhijun", 19, 590);
        persons[2] = new Student("fangyao", 17, 300);
        persons[3] = new Teacher("zhang", 22, 2000);
        persons[4] = new Teacher("chen", 55, 20000);
        //循环遍历多态数组，调用say方法
        for (int i = 0; i < persons.length; i++) {
            //编译类型是person
            System.out.println(persons[i].say());//动态绑定机制
        }
    }
}

//输出

jack	18
学生sizhijun	19 score=590
学生fangyao	17 score=300
老师zhang	22 salary=2000.0
老师chen	55 salary=20000.0
```

进行判断操作

```java
package com.poly.polyarr;

import com.extend_.improve_.student;

public class polyArray {
    public static void main(String[] args) {
        Person[] persons = new Person[5];
        persons[0] = new Person("jack", 18);
        persons[1] = new Student("sizhijun", 19, 590);
        persons[2] = new Student("fangyao", 17, 300);
        persons[3] = new Teacher("zhang", 22, 2000);
        persons[4] = new Teacher("chen", 55, 20000);
        //循环遍历多态数组，调用say方法
        for (int i = 0; i < persons.length; i++) {
            //编译类型是person
            System.out.println(persons[i].say());//动态绑定机制

            //如何调用子类中的方法呢

            //persons[i].teach();
            //persons[i].study();
            //错误，编译类型为Person，Person中没有这些方法

            if(persons[i] instanceof Student){//类型判断
                Student student=(Student) persons[i];//向下转型
                student.study();
                //等价于
                // ((Student)persons[i]).study();
            }else if(persons[i] instanceof Teacher){
                Teacher teacher=(Teacher) persons[i];
                teacher.teach();
                //等价于
                //((Teacher)persons[i]).teach();
            }else if(persons[i] instanceof Person){

            } else {
                System.out.println("你输入的类型有误，请自己检查一遍。。。");
            }

        }
    }
}

```

### 2.多态参数

**定义**：方法定义的形参类型为父类类型，实参类型允许为子类类型

**示例：**

![image-20250429195246405](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250429195246405.png)

```JAVA
public class Employee {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    public double getAnnual(){
        return salary*12;
    }

}

//子类Manager
public class Manager extends Employee{
    private double bonus;

    public Manager(String name, double salary, double bonus) {
        super(name, salary);
        this.bonus = bonus;
    }

    public double getBonus() {
        return bonus;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }
    public void manage(){
        System.out.println("经理"+getName()+"正在做管理工作");
    }
    //重写获取年薪的方法

    @Override
    public double getAnnual() {
        return super.getAnnual()+bonus;
    }
}

//子类Worker
public class Worker extends Employee{
    public Worker(String name, double salary) {
        super(name, salary);
    }
    public void work(){
        System.out.println("普通员工"+getName()+"正在工作");
    }
    public double getAnnual(){//普通员工没有额外收入
        return super.getAnnual();
    }
}

```

```java
//测试f
public class Test {
    public static void main(String[] args) {

        Worker tom = new Worker("tom",2500);
        Manager milan = new Manager("milan", 5000,200000);
        Test a= new Test();
        a.showEmpAnnual(tom);
        a.showEmpAnnual(milan);
        a.testWork(tom);
        a.testWork(milan);
    }

    public void showEmpAnnual(Employee a){
        System.out.println(a.getAnnual());
    }

    public void testWork(Employee e){
        if (e instanceof Manager){
            ((Manager) e).manage();
        }else if(e instanceof Worker){
            ((Worker) e).work();
        }
    }
}
```

