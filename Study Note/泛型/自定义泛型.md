# 自定义泛型

## 一.类

![image-20250522221141584](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250522221141584.png)

```java
//1.Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类
//2. T，R，E 泛型的标识符，可以有多个
//3.普通成员可以使用泛型
class Tiger<T,R,E>{
    String name;
    R r;
    T t;
    E e;
    //T[] ts = new T[8];//因为数组在new 时不能确定T的类型，就无法在内存开空间

    //static R r;
    //public static void m1(E e){}
    //因为静态是和类相关的，在类加载的时候，对象还没有创建
    //如果静态方法和静态属性使用了泛型，JVM就无法完成初始化

    public Tiger(String name, R r, T t, E e) {
        this.name = name;
        this.r = r;
        this.t = t;
        this.e = e;
    }

    public T f(T t){
        return t;
    }
}
```



## 二.接口

![image-20250523163421547](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250523163421547.png)

```java
interface IUsb<U,R>{
    int n = 100;
    //U name;//错误，不能这样使用
    R get(U u);

    void hi(R r);

    void run(R r1, R r2, U u1, U u2);

    default R method(U u){
        return null;
    }
}
interface IA extends IUsb<String,Double>{}

//当我们去实现IA接口时，IA在继承IUsb 接口时，指定了U 为String R为Double
//所以在实现IUsb接口方法时，U R会被替换
class A implements IA{
    @Override
    public void run(Double r1, Double r2, String u1, String u2) {

    }

    @Override
    public void hi(Double aDouble) {

    }

    @Override
    public Double get(String s) {
        return 0.0;
    }
}

//直接指定泛型接口的类型
class BB implements IUsb<Integer,Float>{
    @Override
    public Float get(Integer integer) {
        return 0f;
    }

    @Override
    public void hi(Float aFloat) {

    }

    @Override
    public void run(Float r1, Float r2, Integer u1, Integer u2) {

    }
}
abstract class CC implements IUsb{}
```



## 三.方法

![image-20250523165556246](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250523165556246.png)

```java
public class CustomMethodGeneric {
    public static void main(String[] args) {
        Car car = new Car();
        car.fly("宝马",10000000);
        //当调用方法时，传入参数，编译器自动确定类型
        car.fly(1999,10.98);

        //测试
        Fish<String, ArrayList> fish = new Fish<>();
        fish.hello(new ArrayList(),10.4f);
    }
}
class Car{
    public void run(){//普通
    }

    public<T,R> void fly(T t,R r){//泛型
        System.out.println(t.getClass());
        System.out.println(r.getClass());
    }
}

class Fish<T,R>{
    public void run(){
    }

    public<M,S> void eat(M m,S s){
        System.out.println(m.getClass());
        System.out.println(s.getClass());
    }

    public<K> void hello(R r,K k){
        System.out.println(r.getClass());//class java.util.ArrayList
        System.out.println(k.getClass());//class java.lang.Float
    }
}
```

