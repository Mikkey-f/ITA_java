# 内部类

## 一.介绍

![](C:\Users\24709\Pictures\Screenshots\屏幕截图 2025-05-08 214004.png)



**快速入门：**

```java
package InnerClass;

public class IC01 {//外部其他类
    public static void main(String[] args) {

    }
}
class outer{//外部类
    private int n1=100;

    public outer(int n1) {
        this.n1 = n1;
    }

    public void m1(){
        System.out.println("m1");
    }
    {
        System.out.println("代码块。。。");
    }
    class Inner{//内部类
        
    }
}
```



## 二.分类

![](C:\Users\24709\Pictures\Screenshots\屏幕截图 2025-05-08 214558.png)

### 1.局部内部类

![image-20250509162624084](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250509162624084.png)

![image-20250509164610439](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250509164610439.png)



```java
package InnerClass;

public class IC01 {//外部其他类
    public static void main(String[] args) {
        Outer outer = new Outer(10);
        outer.m2();
        System.out.println("Outer的hashcode="+outer);
    }
}
class Outer{//外部类
    private int n1=100;

    public Outer(int n1) {
        this.n1 = n1;
    }
    private void m1(){}
    public void m2(){

        class Inner{//不能被public修饰，可以用final修饰
            private int n1=11;
            //可以直接访问外部类的所有成员，包含私有的
            public void f1(){
                System.out.println("n1="+n1);//就近原则，输出内部类的n1
                System.out.println("外部类的n1="+Outer.this.n1);
                //解释：Outer.this 本质就是外部类的对象，即哪个对象调用了m2，就是哪个对象（在此处指向outer）
                //用hashcode是否一样判断
                System.out.println(Outer.this);
                m1();
            }
        }
        class Inner03 extends Inner{}//内部类可以被继承

        //外部类在方法中，可以创建Inner对象，然后调用方法即可
        Inner inner = new Inner();
        inner.f1();
    }

}
```



### 2.匿名内部类

#### 2.1细节

![image-20250509170136544](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250509170136544.png)



**示例：**

```java
package InnerClass;

/**
 * 演示匿名内部类
 */
public class AnonymousInner {
    public static void main(String[] args) {
        new Outer02().method();
        //tiger的运行内存：class InnerClass.Outer02$1
        //老虎在叫唤。。。
        //接收到name=sizhijun
        //father对象的运行类型=class InnerClass.Outer02$2

    }
}

class Outer02{
    private int n1 = 10;
    public void method(){

        //基于接口的匿名内部类
        //tiger的编译类型是IA
        //tiger的运行类型就是匿名内部类
        //在new时，jdk底层在创建匿名内部类Outer02$1时，立马创建了Outer02$1的实例对象
        //并且把地址返回给tiger
        //匿名内部类使用一次，就不能再使用了,但tiger是一个对象，可以反复使用
        IA tiger = new IA() {
            @Override
            public void cry() {
                System.out.println("老虎在叫唤。。。");
            }
        };
        //等价于下面这个类
//        class Outer02$1 implements IA{
//            @Override
//            public void cry() {
//                System.out.println("老虎在叫唤。。。");
//            }
//        }

        System.out.println("tiger的运行内存："+tiger.getClass());//getClass得到对象的运行内存
        tiger.cry();

        //演示基于类的匿名内部类
        //分析
        //1.father编译类型 Father
        //2.father运行类型 Outer02$2
        //3.底层会创建匿名类
        /**
         * class Outer04$2 extends Father{
         *    public void test(){
         *     System.out.println("匿名内部类重写了test（）方法");
         *    }
         * }
         */
        //4.同时也直接返回了 匿名内部类 Outer02$2的对象
        //5.注意（"jack"）参数列表会传递给 构造器
        Father father = new Father("sizhijun"){
            public void test(){
                System.out.println("匿名内部类重写了test（）方法");
            }
        };
        System.out.println("father对象的运行类型=" + father.getClass());//Outer02$2

        //基于抽象类的匿名内部类
        Animal animal = new Animal(){
            @Override
            void eat() {
                System.out.println("小狗吃骨头。。。");
            }
        };
    }
}
interface IA {
    public void cry();
}
class Father{
    public Father(String name) {
        System.out.println("接收到name=" + name);
    }
    public void test(){

    }
}
abstract class Animal{
    abstract void eat();
}
```



![image-20250509205822872](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250509205822872.png)



```java
package InnerClass;

public class AnonymousinnerClassDetail {
    public static void main(String[] args) {
        new Outer05().f1();
        //匿名内部类重写了 hi方法
        //匿名内部类重写了 hi方法,hhhhhhhh
        //ok  sizhijun

进程已结束，退出代码为 0

    }
}
class Outer05{
     private int n1=99;
     public void f1(){
         //创建一个基于类的匿名内部类
         //class 匿名内部类 extends person {}
         Person p = new Person(){
             @Override
             public void hi() {
                 System.out.println("匿名内部类重写了 hi方法");
             }
         };

         p.hi();//动态绑定，运行类型是Uoter05$1
         new Person(){
             public void hi() {
                 System.out.println("匿名内部类重写了 hi方法,hhhhhhhh");
             }
         }.hi();

         new Person(){
             @Override
             public void ok(String s) {
                 super.ok(s);//未重写，回到Person类
             }
         }.ok("sizhijun");
     }
}
class Person {
    public void hi(){
        System.out.println("Person hi()");
    }
    public void ok(String s){
        System.out.println("ok  "+s);
    }
}
```





![image-20250509211608354](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250509211608354.png)

![image-20250509212059877](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250509212059877.png)



#### 2.2实践

当作实参直接传递，简洁明了

```java
package InnerClass;


public class Exercise {
    public static void main(String[] args) {
        //当作实参直接传递
        f1(new IL() {
            @Override
            public void show() {
                System.out.println("一幅名画");
            }
        }//看做一个对象);
           
        //传统方式
        f1(new Picture());
    }

    public static void f1(IL il){
        il.show();
    }
}

interface IL{
    void show();
}
//硬编码
class Picture implements IL{
    @Override
    public void show() {
        System.out.println("一幅名画");
    }
}
```



<img src="C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250509213650391.png" alt="image-20250509213650391" style="zoom: 80%;" />



```java
package InnerClass;

public class Exercise02 {
    public static void main(String[] args) {

        Cellphone cellphone = new Cellphone();

        //1.传递的是实现了 Bell接口的匿名内部类
        //2.重写了ring
        //3.Bell bell = new Bell() {
        //            @Override
        //            public void ring() {
        //                System.out.println("懒猪起床了");
        //            }
        //        }

        cellphone.alarmClock(new Bell() {
            @Override
            public void ring() {
                System.out.println("懒猪起床了");
            }
        });
        cellphone.alarmClock(new Bell() {
            @Override
            public void ring() {
                System.out.println("小伙伴起床了");
            }

        });
    }
}

interface Bell {
    void ring();
}

class Cellphone {
    public void alarmClock(Bell bell) {
        System.out.println(bell.getClass());
        bell.ring();//动态绑定机制
    }
}
```





### 3.成员内部类

![image-20250509215055510](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250509215055510.png)

![image-20250509215957497](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250509215957497.png)

![image-20250509222337900](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250509222337900.png)



```java
package InnerClass.Member;

public class Member01 {
    public static void main(String[] args) {
        Outer06 outer06 = new Outer06();
        //外部其他类使用成员内部类的两种方式
        //1.
        //语法，不用纠结
        Outer06.Inner06 inner06_=outer06.new Inner06();

        //2.
        //在外部类中编写一个方法，返回inner06对象
        Outer06.Inner06 inner06Instance = outer06.getInner06();
        inner06Instance.say();

    }
}
class Outer06{
    public int n = 11;
    public String name = "sizhijun";

    public void t2(){
        System.out.println("访问t2方法");
    }

    //1.成员内部类定义在成员位置
    //2.可以添加任意访问修饰符
    class Inner06{
        private int n = 199;
        public void say(){
            //重名，遵循就近原则
            System.out.println("n = " +n +"  name = "+name);//199
            System.out.println("访问outer06的n " + Outer06.this.n);//11
            t2();
        }
        //t2();错误，不能在方法外使用
    }

    public void t1(){
        //使用成员内部类
        Inner06 inner06 = new Inner06();
        inner06.say();
        System.out.println(inner06.n);
    }
    public Inner06 getInner06(){
        //返回Inner06的实例
        Inner06 inner061 = new Inner06();
        return inner061;
    }
}
```



### 4.静态内部类

![image-20250510141706709](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250510141706709.png)

![image-20250510143326958](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250510143326958.png)

![image-20250510144745161](C:\Users\24709\AppData\Roaming\Typora\typora-user-images\image-20250510144745161.png)



```java
package InnerClass.Member;

public class StaticinnerClass {
    public static void main(String[] args) {
        Outer07 outer07 = new Outer07();
        outer07.m();
        //外部其他类 使用静态内部类
        //1.
        Outer07.Inner07 inner07 = new Outer07.Inner07();
        inner07.say();
        //2.
        //编写一个方法，返回一个Inner07的实例
        Outer07.Inner07 inner07_ = outer07.getInner();
        inner07_.say();
        //3.
        //在Outer07中编写一个静态方法，这样通过类名直接返回
        Outer07.Inner07 inner1 = Outer07.getInner1();
        inner1.say();
    }
}
class Outer07{
    private int n=100;
    private static String name = "sizhijun";
    //1.放在外部类的成员位置
    //2.使用static修饰
    private static void cry(){
        System.out.println("a");
    }

    static class Inner07{
        private static String name = "fangyao";
        public void say () {
            //可以访问外部类的所有静态成员
            //可以添加任意修饰符
            //作用域为整个类体
            System.out.println("外部类name=" + Outer07.name+ "  内部类name="+name);
            cry();
        }
    }

    public void m(){
        //外部类访问静态内部类
        Inner07 inner07 = new Inner07();
        inner07.say();
    }
    public Inner07 getInner(){
        return new Inner07();
    }
    static public Inner07 getInner1(){
        return new Inner07();
    }
}
```

