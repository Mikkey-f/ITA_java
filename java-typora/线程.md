# 线程

## 线程的概念

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C62B8AF4F0798C387DA608C9BD1BE776C.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C4F02609E1BA11B7BF3916B0BB4D83716.jpg)

## Thread类

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CC988CA3379C305D1B0099997B63287A0.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C5622CE3C920360951898D9B6AF83E352.jpg)

```
Cat cat=new Cat();//创建Cat对象
        cat.start();//****启动线程-->执行cat的run方法
        //说明:当main线程启动一个子线程Thread-0,主线程不会阻塞,会继续执行
        //这时主线程和子线程交替执行。。。
        for (int i = 0; i < 8; i++) {
            System.out.println("dsadsa"+Thread.currentThread().getName());
            try {
                //让主线程休眠
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }

//1.当一个类继承了Thread类,该类就可以当作线程使用
//2.重写run方法，写上自己的业务代码
//3.run Thread类实现了 Runnable接口的run方法。

class Cat extends Thread{
    @Override
    public void run() {//重写run方法，写上自己的业务逻辑
        int times=0;
        while (true){
            System.out.println("orzorz"+(++times)+Thread.currentThread().getName());
            try {
                //该线程每个1秒输出一次
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if(times==8){
                break;
            }
        }
    }
```

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C54C6C42C3ABBA21783D5927FB998F568.jpg)

## Runnable接口

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CD35B8C159ACA8F68A3AD9CA8DB31BECE.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CBE6376900DAF66B5520132EE1F3E1C80.jpg)

```
//  实现Runnable接口,底层使用了静态代理模式
Dog dog=new Dog();
         //dog.start 无法调用
        //创建Thread对象,把dog对象(实现Runnable),放入Thread中
        Thread thread=new Thread(dog);
        thread.start();

        Threadproxy threadproxy=new Threadproxy(dog);
        threadproxy.start();
        
        
//模拟代理模式
class Threadproxy implements Runnable{
    private Runnable target=null;
    @Override
    public void run() {
        if(target!=null){
            target.run();
        }
    }
    public Threadproxy(Runnable target){
        this.target=target;
    }
    public void start(){
        start0();
    }
    public void start0(){
        run();
    }
}
class Dog implements Runnable{

    @Override
    public void run() {//普通方法
        int cnt=0;
        while (true){
            System.out.println("狗正在叫"+(++cnt)+Thread.currentThread().getName());

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if(cnt==10){
                break;
            }
        }

    }
}

```

## Thread和Runnable的区别

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CBC1729C4F0C4081AA37973079B40AFF0.jpg)

```
/**
 * 多个子线程案例
 * main方法启动两个子线程
 */
public class Thread03 {
    public static void main(String[] args) {
        person1 prs1=new person1();
        person2 prs2=new person2();
        Thread thread1=new Thread(prs1);
        Thread thread2=new Thread(prs2);
        thread1.start();
        thread2.start();
    }
}
class person1 implements Runnable{

    @Override
    public void run() {
        int num1=0;
        while (true){
            System.out.println("hello!"+Thread.currentThread().getName());
            ++num1;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if(num1==10){
                break;
            }
        }
    }
}
class person2 implements Runnable{

    @Override
    public void run() {
        int num2=0;
        while (true){
            System.out.println("Hi"+Thread.currentThread().getName());
            ++num2;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if(num2==5){
                break;
            }
        }
    }
}
```

## 退出线程

```
public class ThreadExit {
    public static void main(String[] args) throws InterruptedException {
        T t1=new T();
        t1.start();

        //如果希望 main线程去控制t1线程的终止,必须可以修改 loop
        //让t1退出run方法,从而终止t1线程---->通知方式

        //让主线程休眠5s
        Thread.sleep(5*1000);
        t1.setLoop(false);
    }
}
class T extends Thread{
    int cnt=0;
    //设置一个控制变量
    private  boolean loop=true;
    @Override
    public void run() {
        while (loop){
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("hello!"+(++cnt));
        }
    }

    public void setLoop(boolean loop) {
        this.loop = loop;
    }
}
```

## 线程的常用方法

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C8FCD18B2DAF227D633D363CCB320CCB1.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CB80047A5F7E3BB42F9BD559F80CF6D82.jpg)



```
/**
 *  常用方法第一组:
 *  1.setName 设置线程名称,使之与参数name相同
 *  2.getName 返回该线程名称
 *  3.start 使该线程开始执行,底层调用start0方法
 *  4.run 调用线程对象run方法
 *  5.setPriority 更改线程的优先级-->1:最低级  10：最高级
 *  6.getPriority 获取线程的优先级
 *  7.sleep   8.interrupt 中断线程-->指的是唤醒休眠线程
 */
 
        T t = new T();

        t.setName("狗");
        t.setPriority(1);
        t.start();
        for (int i = 0; i < 5; i++) {
            Thread.sleep(2000);
            System.out.println("hi");
        }
        t.interrupt();//唤醒t线程
        
class T extends Thread{
    @Override
    public void run() {
        while (true){
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName()+" 在吃包子 "+i);
            }
            try {
                System.out.println(Thread.currentThread().getName()+"休眠中");
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName()+"被唤醒了");
            }
        }
    }
}
```

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C611E8F96C4E7EDC65850D08C18113B0B.jpg)

```
/**
 * 常用方法第二组:  1.yield:线程的礼让.让出cpu,让其他线程执行,但礼让时间不确定,也不一定能礼让成功
 *               2.join:线程的插队.插队的线程一旦插队成功,则先完成插入的线程的所有任务
 */
 
T1 t = new T1();
        t.start();
        for(int i=1;i<=20;i++){
            System.out.println("hi"+i);
            Thread.sleep(1000);
            if(i==5){
                t.join();//相当于让t线程先执行完毕,再执行主线程
                //Thread.yield();礼让,不一定成功.
            }
        }
        System.out.println("主线程结束");
        
        
class T1 extends Thread{
    @Override
    public void run() {
        int cnt=0;
        while (true){
            System.out.println("hello"+(++cnt));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if(cnt==20) {
                System.out.println("子线程结束");
                break;
            }
        }
    }
}
```



![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CC0AD5B477F53BCD3D2CA664C8CF007C1.jpg)

```
/**
 *  线程的常用方法3.
 *  用户线程和守护线程:
 *  1.用户线程:也叫工作线程,当线程的任务执行完或通知方式结束
 *  2.守护线程:为工作线程服务,当所有的用户线程结束,守护线程自动结束。(例:垃圾回收机制)
 */
 
 //将子线程设置为守护线程,如果我们希望main线程结束后子线程自动结束。
        people p1 = new people();
        p1.setDaemon(true);
        p1.start();
        for(int i=1;i<=10;i++){
            Thread.sleep(1000);
            System.out.println("hello!");
        }
        
    class people extends Thread{
    @Override
    public void run() {
        while (true){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("hihihi");
        }
    }
}    
```

## 线程的生命周期

<img src="C:%5CUsers%5C23139%5COneDrive%5CPictures%5C87CF76687E935C1229F6056C04892A7D.jpg" style="zoom:200%;" />

<img src="C:%5CUsers%5C23139%5COneDrive%5CPictures%5C4733703D49BDC235955DF06608DAFB05.jpg" style="zoom: 200%;" />

```
 T t = new T();
        System.out.println(t.getName()+"状态"+t.getState());
        t.start();
        while (Thread.State.TERMINATED!=t.getState()){
            System.out.println(t.getName()+"状态"+t.getState());
            Thread.sleep(500);
        }
        System.out.println(t.getName()+"状态"+t.getState());

class T extends Thread{
    @Override
    public void run() {
        while (true){
            for (int i = 0; i < 10; i++) {
                System.out.println("Hi"+i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            break;
        }
    }
}
```

## 线程同步机制

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C81ED819FC0DE065762527627B6A7B84E.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CB2231808B0E4A08789DF7B5B4A64EB9F.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CBC41EAEFE85240B4530001F097D2F457.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CB02A1FC63A014DFA7FC0F9441FDD4D0B.jpg)



```
----------------------互斥锁-------------------------------------
1.每个对象都对应一个可称为互斥锁的标记,这个标记用来保证在任一时刻，只能有一个线程访问对象
2.关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问
3.同步的局限性:导致程序的执行效率降低。
4.同步方法(非静态的)的锁可以是this,也可以是其他对象（要求是同一个对象）******
5.同步方法（静态的）的锁为当前类本身.
6.用Thread由于会创建多个对象，所以不行

解决超卖问题:
public class sellticket01 {
    public static void main(String[] args) {
       
        Selltickets03 selltickets03 = new Selltickets03();
        new Thread(selltickets03).start();
        new Thread(selltickets03).start();
        new Thread(selltickets03).start();
    }
}

//说明:
//1.public synchronized void sell() 就是一个同步方法
//2.这时所在this对象--->该程序中即为  selltickets03。
//3.也可以在代码块上写synchronized，同步代码块，互斥锁还是在this对象

class Selltickets03 implements Runnable{//同步方法，同一时刻，只能有一个线程执行sell方法
    private  int num=100;//多个线程共享
    private boolean loop=true;
    Object object=new Object();//由于是同一对象创建的，所以也不会超卖

    //同步方法（静态的）
    //1.public synchronized static void m1(){//锁是加在Selltickets03,class这个对象上
    public synchronized static void m1(){//锁是加在Selltickets03,class这个对象上

    }
    public static void m2(){
        synchronized (/*this:会报错*/Selltickets03.class){
            System.out.println("114514");
        }
    }
    //同步方法(非静态的)
    public /*synchronized*/ void sell(){
        synchronized (/*object*/this){
            if (num<=0){
                System.out.println("售票结束!");
                loop=false;
                return;
            }
            //休眠
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("窗口 "+Thread.currentThread().getName()+" 卖出了一张票"+",剩余"+(--num)+"张票");
        }
    }
    @Override
    public  void run() {//同步方法,在同一时刻,只能有一个线程执行run方法
        while (loop){
            sell();
        }
    }
}
```

## 死锁

```
//1.如果flag为T,线程就会先得到/持有o1对象锁
//如果线程A得不到o2对象锁,就会Blocked
//3.如果flag为F,线程B先得到o2对象锁,然后尝试获取o1的对象锁,如果线程B得不到o1对象锁,就会Blocked

Deadlock a = new Deadlock(true);
        a.setName("a线程");
        Deadlock b = new Deadlock(false);
        b.setName("b线程");
        a.start();
        b.start();
        
class Deadlock extends Thread{
    //静态方法,指向同一对象
    static Object o1=new Object();
    static Object o2=new Object();
    boolean flag;

    public Deadlock(boolean flag) {
        this.flag = flag;
    }
    @Override
    public void run() {
        if(flag){
            synchronized (o1) {//对象互斥锁
                System.out.println(Thread.currentThread().getName() + "进入1");
                synchronized (o2) {
                    System.out.println(Thread.currentThread().getName() + "进入2");
                }
            }
        }
        else{
            synchronized (o2) {

                System.out.println(Thread.currentThread().getName() + "进入3");
                synchronized (o1) {
                    System.out.println(Thread.currentThread().getName() + "进入4");
                }
            }
        }
    }
}
```

## 释放锁

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C2DFC3ADC4341106CCB53969AD3C210C1.jpg)

释放锁

1.当前线程的同步方法，同步代码块执行结束

2.当前线程在同步代码块，同步方法中遇到break，return.

3.当前线程在同步代码块，同步方法中出现了未处理的Error或Exception,导致异常结束

4.当前线程在同步代码块，同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C07F740D8C340164F10F943091C50E808.jpg)

## 本章练习

1.

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CE48C68F1E623650D6951739516759347.jpg)

```
package eduxiancheng.LockPractice;

import java.util.Random;
import java.util.Scanner;

public class LockPractice1 {
    public static void main(String[] args) {
        A a=new A();
        B b=new B(a);
        a.start();
        b.start();

    }
}
class A extends Thread{
    boolean loop=true;

    public void setLoop(boolean loop) {
        this.loop = loop;
    }

    @Override
    public void run() {
        Random r = new Random();
            while (loop){

                System.out.println(r.nextInt(100));
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        System.out.println("退出a线程");
    }
}
class B extends Thread{
    private A a;
    private Scanner sc=new Scanner(System.in);
    public B(A a) {
        this.a = a;
    }

    @Override
    public void run() {
        while (true){
            System.out.println("请输入Q来结束线程");
            char s=sc.next().toUpperCase().charAt(0);
            if(s=='Q'){
                 a.setLoop(false);
                 System.out.println("退出b线程");
                 break;
            }
        }
    }
}
```

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CF112B9D7693F13F2E1D7B2C9B4A5884C.jpg)

```
public class ThreadPractice2 {
    public static void main(String[] args) {
        user user = new user();
        new Thread(user).start();
        new Thread(user).start();
    }
}
//用Runnable原因:1.因为这里涉及到多个线程共享资源,所以用Runnable
class user implements Runnable{
    private int money=10000;
    boolean loop=true;
    public void take(){
        synchronized (this){
            if(money<1000){
                System.out.println("余额不足了,不能取款了");
                loop=false;
                return;
            }
            else {
                money-=1000;
                System.out.println(Thread.currentThread().getName()+"取走了1000块"+"还剩:"+money);
            }
        }
    }
    @Override
    public void run() {
        while(loop){
            //take();
            synchronized (this){ //哪个线程争夺到了this对象的锁，就执行该代码块，执行后会释放this对象锁
                                 //争夺不到的线程就阻塞，准备继续争夺，已经争夺到并且执行完的线程可以继续争夺
                if(money<1000){
                    System.out.println("余额不足");
                    break;
                }
                else{
                    money-=1000;
                    System.out.println(Thread.currentThread().getName()+"取出了1000,当前的余额为:"+money);
                }
            }
        }

    }
}
```