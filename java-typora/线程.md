

# 线程

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C62B8AF4F0798C387DA608C9BD1BE776C.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C4F02609E1BA11B7BF3916B0BB4D83716.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CC988CA3379C305D1B0099997B63287A0.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C5622CE3C920360951898D9B6AF83E352.jpg)

```
Cat cat=new Cat();//创建Cat对象
        cat.start();//****启动线程-->执行cat的run方法
        //说明:当main线程启动一个子线程Thread-0,主线程不会阻塞,会继续执行
        //这时主线程和子线程交替执行。。。
        for (int i = 0; i < 8; i++) {
            System.out.println("dsadsa"+Thread.currentThread().getName());
            try {
                //让主线程休眠
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }

//1.当一个类继承了Thread类,该类就可以当作线程使用
//2.重写run方法，写上自己的业务代码
//3.run Thread类实现了 Runnable接口的run方法。

class Cat extends Thread{
    @Override
    public void run() {//重写run方法，写上自己的业务逻辑
        int times=0;
        while (true){
            System.out.println("orzorz"+(++times)+Thread.currentThread().getName());
            try {
                //该线程每个1秒输出一次
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if(times==8){
                break;
            }
        }
    }
```

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C54C6C42C3ABBA21783D5927FB998F568.jpg)



![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CD35B8C159ACA8F68A3AD9CA8DB31BECE.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CBE6376900DAF66B5520132EE1F3E1C80.jpg)

```
//  实现Runnable接口,底层使用了静态代理模式
Dog dog=new Dog();
         //dog.start 无法调用
        //创建Thread对象,把dog对象(实现Runnable),放入Thread中
        Thread thread=new Thread(dog);
        thread.start();

        Threadproxy threadproxy=new Threadproxy(dog);
        threadproxy.start();
        
        
//模拟代理模式
class Threadproxy implements Runnable{
    private Runnable target=null;
    @Override
    public void run() {
        if(target!=null){
            target.run();
        }
    }
    public Threadproxy(Runnable target){
        this.target=target;
    }
    public void start(){
        start0();
    }
    public void start0(){
        run();
    }
}
class Dog implements Runnable{

    @Override
    public void run() {//普通方法
        int cnt=0;
        while (true){
            System.out.println("狗正在叫"+(++cnt)+Thread.currentThread().getName());

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if(cnt==10){
                break;
            }
        }

    }
}

```

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CBC1729C4F0C4081AA37973079B40AFF0.jpg)

```
/**
 * 多个子线程案例
 * main方法启动两个子线程
 */
public class Thread03 {
    public static void main(String[] args) {
        person1 prs1=new person1();
        person2 prs2=new person2();
        Thread thread1=new Thread(prs1);
        Thread thread2=new Thread(prs2);
        thread1.start();
        thread2.start();
    }
}
class person1 implements Runnable{

    @Override
    public void run() {
        int num1=0;
        while (true){
            System.out.println("hello!"+Thread.currentThread().getName());
            ++num1;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if(num1==10){
                break;
            }
        }
    }
}
class person2 implements Runnable{

    @Override
    public void run() {
        int num2=0;
        while (true){
            System.out.println("Hi"+Thread.currentThread().getName());
            ++num2;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if(num2==5){
                break;
            }
        }
    }
}
```

## 退出线程

```
public class ThreadExit {
    public static void main(String[] args) throws InterruptedException {
        T t1=new T();
        t1.start();

        //如果希望 main线程去控制t1线程的终止,必须可以修改 loop
        //让t1退出run方法,从而终止t1线程---->通知方式

        //让主线程休眠5s
        Thread.sleep(5*1000);
        t1.setLoop(false);
    }
}
class T extends Thread{
    int cnt=0;
    //设置一个控制变量
    private  boolean loop=true;
    @Override
    public void run() {
        while (loop){
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("hello!"+(++cnt));
        }
    }

    public void setLoop(boolean loop) {
        this.loop = loop;
    }
}
```

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5C8FCD18B2DAF227D633D363CCB320CCB1.jpg)

![](C:%5CUsers%5C23139%5COneDrive%5CPictures%5CB80047A5F7E3BB42F9BD559F80CF6D82.jpg)

```
/**
 *  常用方法第一组:
 *  1.setName 设置线程名称,使之与参数name相同
 *  2.getName 返回该线程名称
 *  3.start 使该线程开始执行,底层调用start0方法
 *  4.run 调用线程对象run方法
 *  5.setPriority 更改线程的优先级-->1:最低级  10：最高级
 *  6.getPriority 获取线程的优先级
 *  7.sleep   8.interrupt 中断线程-->指的是唤醒休眠线程
 */
 
        T t = new T();

        t.setName("狗");
        t.setPriority(1);
        t.start();
        for (int i = 0; i < 5; i++) {
            Thread.sleep(2000);
            System.out.println("hi");
        }
        t.interrupt();//唤醒t线程
        
class T extends Thread{
    @Override
    public void run() {
        while (true){
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName()+" 在吃包子 "+i);
            }
            try {
                System.out.println(Thread.currentThread().getName()+"休眠中");
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName()+"被唤醒了");
            }
        }
    }
}
```

```
/**
 * 常用方法第二组:  1.yield:线程的礼让.让出cpu,让其他线程执行,但礼让时间不确定,也不一定能礼让成功
 *               2.join:线程的插队.插队的线程一旦插队成功,则先完成插入的线程的所有任务
 */
 
T1 t = new T1();
        t.start();
        for(int i=1;i<=20;i++){
            System.out.println("hi"+i);
            Thread.sleep(1000);
            if(i==5){
                t.join();//相当于让t线程先执行完毕,再执行主线程
                //Thread.yield();礼让,不一定成功.
            }
        }
        System.out.println("主线程结束");
        
        
class T1 extends Thread{
    @Override
    public void run() {
        int cnt=0;
        while (true){
            System.out.println("hello"+(++cnt));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if(cnt==20) {
                System.out.println("子线程结束");
                break;
            }
        }
    }
}
```

```
/**
 *  线程的常用方法3.
 *  用户线程和守护线程:
 *  1.用户线程:也叫工作线程,当线程的任务执行完或通知方式结束
 *  2.守护线程:为工作线程服务,当所有的用户线程结束,守护线程自动结束。(例:垃圾回收机制)
 */
 
 //将子线程设置为守护线程,如果我们希望main线程结束后子线程自动结束。
        people p1 = new people();
        p1.setDaemon(true);
        p1.start();
        for(int i=1;i<=10;i++){
            Thread.sleep(1000);
            System.out.println("hello!");
        }
        
    class people extends Thread{
    @Override
    public void run() {
        while (true){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("hihihi");
        }
    }
}    
```